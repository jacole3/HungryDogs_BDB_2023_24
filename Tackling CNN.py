# -*- coding: utf-8 -*-
"""CNN
# this example is trained on week 1 and tests output on week 3
Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_LXvE1q40Pz0UiZ1eAS-2F29ny_feQPH
"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report
import xgboost as xgb
import numpy as np
import pandas as pd
import math

from google.colab import drive
drive.mount("/content/gdrive", force_remount=True)

#Pulling In Data
TW1_BlockInfo=pd.read_csv("/content/gdrive/MyDrive/Big Data Bowl/nfl-big-data-bowl-2024-files/Blocked Info Python/TrackingWeek1_BlockedInfo.csv")
#I realize this could be better but don't change the DF name from TW1ModelInfo
TW1ModelInfo=pd.read_csv("/content/gdrive/MyDrive/Big Data Bowl/nfl-big-data-bowl-2024-files/final_week_1.csv")
final_week3DF=pd.read_csv("/content/gdrive/MyDrive/Big Data Bowl/nfl-big-data-bowl-2024-files/final_week_3.csv")

def FixingBlockingScore(DF):
  #fixes Blocking Score
  DFTemp=DF.loc[(DF.BlockedScore!=0) & (DF.BlockedScore!=25)&(DF.a>=1)]
  DFTemp2=DF.loc[(DF.BlockedScore!=0) & (DF.BlockedScore!=25)&(DF.a<1)]
  DFTemp2.BlockedScore=DFTemp2.BlockedScore*DFTemp2.s
  DFTemp.BlockedScore=(DFTemp.BlockedScore/DFTemp.a)*DFTemp.s
  DFTempWhole=pd.concat([DFTemp,DFTemp2],ignore_index=True)
  DF=DF.merge(DFTempWhole, on=list(DFTempWhole.columns),how='left')
  DF.BlockedScore.replace(25,np.nan,inplace=True)
  return DF

# Define a function to check if the next 5 frames have 'event' == 'tackle'
def check_next_frames(df):
    shifts = [-1, -2, -3, -4]
    conditions = [df['event'].shift(shift, fill_value=np.nan) == 'tackle' for shift in shifts]
    return pd.DataFrame(conditions).any(axis=0)
#Marks Tackles in next 5 frames for model
def TackleInNext5(DF):
  df1=DF.groupby(['gameId', 'playId', 'frameId']).agg({'event': 'last'}).reset_index()
  df1.sort_values(by=['gameId', 'playId', 'frameId'], inplace=True)
  # Reset the index before applying the function
  grouped_df = df1.groupby(['gameId', 'playId']).apply(check_next_frames).astype(int).reset_index(level=0, drop=True)

  # Merge the result back to the original DataFrame
  #original_df = df1.merge(grouped_df.rename('Tackle'), left_index=True, right_index=True)
  df1['tackle_in_next_5']=list(grouped_df)
  # Display the new DataFrame
  df1['tackle_in_next_5']=np.where(df1['event']=='tackle',1,df1['tackle_in_next_5'])
  df1.drop('event',axis=1,inplace=True)
  DF=DF.merge(df1,on=['gameId','playId','frameId'],how='left')

  #DF.drop('Unnamed: 0',axis=1,inplace=True)
  DF=FixingBlockingScore(DF)
  TW1ModelInfo['BlockedScore']=(TW1ModelInfo.BlockedScore-TW1ModelInfo.BlockedScore.min())/(TW1ModelInfo.BlockedScore.max()-TW1ModelInfo.BlockedScore.min())
  return DF

import xgboost as xgb
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
#Gets DataFrame ready for modeling
def CNN_Data(DF):
  GradientBoostedTW1=DF[['gameId','playId','frameId','tackle_in_next_5','BlockedScore','min_proj_dist_to_ball_carrier','dist_to_ball_carrier','NumberOfBlockers','weight','CosSimilarity_Dir_ToBC','CosSimilarity_Orient_ToBC','s']]
  agg_df = GradientBoostedTW1.groupby(['gameId', 'playId','frameId','tackle_in_next_5'])[['BlockedScore','min_proj_dist_to_ball_carrier','dist_to_ball_carrier','NumberOfBlockers','weight','CosSimilarity_Dir_ToBC','CosSimilarity_Orient_ToBC','s']].agg(list).reset_index()


  agg_df['all_players'] = agg_df.apply(lambda row: np.concatenate(row[['BlockedScore','min_proj_dist_to_ball_carrier','NumberOfBlockers','weight','CosSimilarity_Dir_ToBC','CosSimilarity_Orient_ToBC','s']]), axis=1)

  from keras.preprocessing.sequence import pad_sequences
  BlockedScoreVector=agg_df['BlockedScore'].values
  blockedscore = pad_sequences(BlockedScoreVector, dtype='float32', padding='post', truncating='post', value=100)

  ProjDistToBallCarrierVector=agg_df['min_proj_dist_to_ball_carrier'].values
  ProjDistToBallCarrier=pad_sequences(ProjDistToBallCarrierVector, dtype='float32', padding='post', truncating='post', value=20)

  dist_to_ball_carrierVector=agg_df['dist_to_ball_carrier'].values
  dist_to_ball_carrier=pad_sequences(dist_to_ball_carrierVector, dtype='float32', padding='post', truncating='post', value=20)

  NumberOfBlockersVector=agg_df['NumberOfBlockers'].values
  NumberOfBlockers=pad_sequences(dist_to_ball_carrierVector, dtype='float32', padding='post', truncating='post', value=-1)

  WeightVector=agg_df['weight'].values
  Weight=pad_sequences(WeightVector, dtype='float32', padding='post', truncating='post', value=0)

  CosSimilarity_Dir_ToBCVector=agg_df['CosSimilarity_Dir_ToBC'].values
  CosSimilarity_Dir_ToBC=pad_sequences(CosSimilarity_Dir_ToBCVector, dtype='float32', padding='post', truncating='post', value=0)

  CosSimilarity_Orient_ToBCVector=agg_df['CosSimilarity_Orient_ToBC'].values
  CosSimilarity_Orient_ToBC=pad_sequences(CosSimilarity_Orient_ToBCVector, dtype='float32', padding='post', truncating='post', value=0)

  sVector=agg_df['s'].values
  s=pad_sequences(sVector,dtype='float32', padding='post', truncating='post', value=0)

  CNN_ModelDF = pd.DataFrame({'tackle_in_next_5':list(agg_df['tackle_in_next_5']),
                            'BlockedScore': list(blockedscore),
                            'min_proj_dist_to_ball_carrier':list(ProjDistToBallCarrier),
                            'dist_to_ball_carrier':list(dist_to_ball_carrier),
                            'NumberOfBlockers':list(NumberOfBlockers),
                            'weight':list(Weight),
                            'CosSimilarity_Dir_ToBC':list(CosSimilarity_Dir_ToBC),
                            'CosSimilarity_Orient_ToBC':list(CosSimilarity_Orient_ToBC),
                            's':list(s)})
  return CNN_ModelDF

#Pass in Dataframe you want to train on
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from sklearn.metrics import precision_score, recall_score

def Fit_and_BuildCNN(DF):

  CNN_ModelDF=CNN_Data(DF)
  X=CNN_ModelDF[['BlockedScore','min_proj_dist_to_ball_carrier','dist_to_ball_carrier','NumberOfBlockers','weight','CosSimilarity_Dir_ToBC','CosSimilarity_Orient_ToBC','s']].values
  Y=CNN_ModelDF['tackle_in_next_5'].values
  X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, random_state=42)




  X_train = np.array([np.hstack(x) for x in X_train])
  X_test = np.array([np.hstack(x) for x in X_test])
  X_train=X_train.reshape(-1,8,11,1)
  X_test=X_test.reshape(-1,8,11,1)


  model = Sequential()
  model.add(Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=(8, 11, 1)))
  model.add(MaxPooling2D(pool_size=(2, 2)))
  model.add(Flatten())
  model.add(Dense(128, activation='relu'))
  model.add(Dense(1, activation='sigmoid'))

  # Compile the model
  model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
  # Train the model
  model.fit(X_train, y_train, epochs=10, batch_size=32, validation_data=(X_test, y_test))

  # Evaluate the model on the test set
  test_loss, test_accuracy = model.evaluate(X_test, y_test)
  print(f'Test Loss: {test_loss:.4f}, Test Accuracy: {test_accuracy:.4f}')

  probabilities = model.predict(X_test)

# Convert probabilities to binary predictions (0 or 1) based on a threshold
  threshold = 0.5
  predictions = (probabilities > threshold).astype(int)
  precision = precision_score(y_test, predictions)
  recall = recall_score(y_test, predictions)

  print(f'Test Precision: {precision:.4f}, Test Recall: {recall:.4f}')
  return model
def predict(model,DF):
  DFPredict=CNN_Data(DF)
  X=DFPredict[['BlockedScore','min_proj_dist_to_ball_carrier','dist_to_ball_carrier','NumberOfBlockers','weight','CosSimilarity_Dir_ToBC','CosSimilarity_Orient_ToBC','s']].values
  X=np.array([np.hstack(x) for x in X])
  X=X.reshape(-1,8,11,1)
  probabilities=model.predict(X)
  DF=DF[['gameId','playId','frameId','tackle_in_next_5']].drop_duplicates()
  DF['preds'] = list(probabilities.squeeze())
  return DF

TW1ModelInfo=TackleInNext5(TW1ModelInfo)
model1=Fit_and_BuildCNN(TW1ModelInfo)

final_week3DFTemp=TackleInNext5(final_week3DF)
DF=predict(model1,final_week3DFTemp)

row=DF.sample(n=1)
DF.loc[(DF.gameId==int(row.gameId)) & (DF.playId==int(row.playId))]

model1.summary()

